#!/usr/bin/env python3

"""
Run smoke tests - basic use-case checks with default data

https://en.wikipedia.org/wiki/Smoke_testing_(software)

Usage:

    ./tests/run-smoke-tests 'target/release/treetime'

NOTE: you must build and re-build the tested executable yourself, this script does not do that


How to add more tests:

1. Add ancestral commands by adding entries to `ANCESTRAL_BATCH_RUNS`
2. Add clock commands by adding entries to `CLOCK_BATCH_RUNS`
3. Add arbitrary commands to `make_additional_commands()`

"""

import os
import subprocess
import sys
from multiprocessing import Pool, cpu_count
from pathlib import Path
from signal import signal, SIGINT, SIG_IGN
from textwrap import dedent
from typing import List, Optional

verbose = False

# Add ancestral command runs here.
# Each entry corresponds to 2 ancestral command runs - one with parsimony and one with marginal method.
# fmt: off @formatter:off
ANCESTRAL_BATCH_RUNS = [
  # data subdirectory             # output subdirectory       # additional args (appended to the batch args)
  ("dengue/500",                  "dengue/500",               ""),
  # ("dengue/1000",                 "dengue/1000",              ""),
  # ("dengue/2000",                 "dengue/2000",              ""),
  ("ebola",                       "ebola",                    ""),
  ("flu/h3n2/20",                 "flu/h3n2/20",              ""),
  ("flu/h3n2/200",                "flu/h3n2/200",             ""),
  ("flu/h3n2/500",                "flu/h3n2/500",             ""),
  ("lassa/L/50",                  "lassa/L/50",               ""),
  ("lassa/L/200",                 "lassa/L/200",              ""),
  ("lassa/L/500",                 "lassa/L/500",              ""),
  ("mpox/clade-ii/500",           "mpox/clade-ii/500",        ""),
  # ("mpox/clade-ii/1000",          "mpox/clade-ii/1000",       ""),
  # ("mpox/clade-ii/2000",          "mpox/clade-ii/2000",       ""),
  ("rsv/a/500",                   "rsv/a/500",                ""),
  # ("rsv/a/1000",                  "rsv/a/1000",               ""),
  # ("rsv/a/2000",                  "rsv/a/2000",               ""),
  ("tb",                          "tb",                       ""),
  ("zika",                        "zika",                     "")
]
# fmt: on @formatter:on

# Add clock command runs here. Each entry corresponds to 1 clock command run
# fmt: off @formatter:off
CLOCK_BATCH_RUNS = [
  # data subdirectory             # output subdirectory       # additional args (appended to the batch args)
  ("dengue/500",                  "dengue/500",               "--name-column=genbank_accession"),
  # ("dengue/1000",                 "dengue/1000",              "--name-column=genbank_accession"),
  # ("dengue/2000",                 "dengue/2000",              "--name-column=genbank_accession"),
  ("ebola",                       "ebola",                    ""),
  ("flu/h3n2/20",                 "flu/h3n2/20",              "--sequence-length=1400"),
  ("flu/h3n2/200",                "flu/h3n2/200",             "--sequence-length=1400"),
  ("flu/h3n2/500",                "flu/h3n2/500",             "--sequence-length=1400"),
  ("lassa/L/50",                  "lassa/L/50",               ""),
  ("lassa/L/200",                 "lassa/L/200",              ""),
  ("lassa/L/500",                 "lassa/L/500",              ""),
  ("mpox/clade-ii/500",           "mpox/clade-ii/500",        ""),
  # ("mpox/clade-ii/1000",          "mpox/clade-ii/1000",       ""),
  # ("mpox/clade-ii/2000",          "mpox/clade-ii/2000",       ""),
  ("rsv/a/500",                   "rsv/a/500",                ""),
  # ("rsv/a/1000",                  "rsv/a/1000",               ""),
  # ("rsv/a/2000",                  "rsv/a/2000",               ""),
  ("tb",                          "tb",                       ""),
  ("zika",                        "zika",                     "")
]
# fmt: on @formatter:on


# Add arbitrary CLI invocations here
def make_additional_commands(exe, data_dir, out_dir):
  """
  Create additional commands for testing

  Substitute these variables:
    {exe} - path to the executable
    {data_dir} - path to input data directory
    {out_dir} - path to output directory (common for all the additional commands, so make sure to add a distinct subdirectory)
  """

  # fmt: off @formatter:off
  return [
    # display name                 # full command line
    ("help: global",               f"""{exe} --help"""                          ),
    ("help: ancestral",            f"""{exe} ancestral --help"""                ),
    ("help: clock",                f"""{exe} clock --help"""                    ),
  ]
  # fmt: on @formatter:on


def blue(text):
  return f"\033[38;5;32m{text}\033[0m"


def red(text):
  return f"\033[38;5;203m{text}\033[0m"


def orange(text):
  return f"\033[38;5;166m{text}\033[0m"


def green(text):
  return f"\033[38;5;113m{text}\033[0m"


def grey(text):
  return f"\033[38;5;244m{text}\033[0m"


def run_cmd(name: str, cmd: str):
  output = []
  code = 0
  try:
    result = subprocess.run(
      cmd,
      shell=True,
      stdout=subprocess.DEVNULL,
      stderr=subprocess.PIPE,
      text=True,
      env={**os.environ, 'CLICOLOR_FORCE': '1'}
    )
    output.append(result.stderr or "")
    code = result.returncode
  except subprocess.CalledProcessError as e:
    output.append(e.output)
    code = e.returncode
  return output, code


def clean_cmd(cmd: str) -> str:
  return " ".join(dedent(cmd).splitlines()).strip()


def run_batch_cmd(data_name: str, cmd_name: str, cmd: str):
  cmd = clean_cmd(cmd)
  output, code = run_cmd(data_name, cmd)
  if code != 0 or verbose:
    status = "🚨 Failed" if code != 0 else "🏁 Finished"
    print("\n".join([f"{status}: {orange(cmd_name)} for {blue(data_name)}\n", grey(f"+{cmd}")] + output))
  return {"data_name": data_name, "cmd_name": cmd_name, "cmd": cmd, "code": code}


def run_additional_cmd(cmd_name, cmd):
  cmd = clean_cmd(cmd)
  output, code = run_cmd(cmd_name, cmd)
  if code != 0 or verbose:
    status = "🚨 Failed" if code != 0 else "🏁 Finished"
    print("\n".join([f"{status}: {orange(cmd_name)}\n", grey(f"+{cmd}")] + output))
  return {"data_name": None, "cmd_name": cmd_name, "cmd": cmd, "code": code}


def run_clock(name: str, out: str, extra_args: str):
  cmd = f"""
  {TREETIME_BIN} clock
  --tree={DATA_DIR}/{name}/tree.nwk
  --dates={DATA_DIR}/{name}/metadata.tsv
  --outdir={RESULTS_DIR}/clock/{out}
  {extra_args}
  """
  return run_batch_cmd(name, "clock", cmd)


def run_ancestral(method: str, seq_mode: Optional[str], name: str, out: str, extra_args: str):
  outdir_base = f"{RESULTS_DIR}/ancestral/{method}"
  dense = ""
  if method == "marginal":
    if seq_mode == "dense":
      dense = "--dense=true --model=jc69"
      outdir_base = f"{outdir_base}-dense"
    else:
      dense = "--dense=false"
      outdir_base = f"{outdir_base}-sparse"

  cmd = f"""
  {TREETIME_BIN} ancestral
  --method-anc={method}
  {dense}
  --tree={DATA_DIR}/{name}/tree.nwk
  --outdir={outdir_base}/{out}
  {DATA_DIR}/{name}/aln.fasta.xz
  {extra_args}
  """

  method_str = f"ancestral-{method}"
  if method == "marginal" and seq_mode is not None:
    method_str = f"{method_str}-{seq_mode}"

  return run_batch_cmd(name, method_str, cmd)


def init_worker():
  signal(SIGINT, SIG_IGN)


def count_by(predicate, arr):
  return sum(map(predicate, arr))


def print_summary(results: List[dict]):
  n = len(results)
  failures = list(filter(lambda res: res["code"] != 0, results))
  n_err = len(failures)
  n_ok = n - n_err

  if n > 0:
    f_color = red if n_err > 0 else lambda x: x
    print("\n".join([
      "", blue(f"Total tests: {n}"), green(f"  Succeeded: {n_ok}"), f_color(f"  Failed:    {n_err}"), ""
    ]))

    if n_err > 0:
      failures = [""] + [failure["cmd"] for failure in failures]
      print(red("Failed commands:" + "\n\n  ".join(failures) + "\n\n"))

    sys.exit(0 if n_err == 0 else 1)
  else:
    print("No tests found")
    sys.exit(1)


if __name__ == "__main__":
  if len(sys.argv) < 2:
    sys.exit(f"Usage: {sys.argv[0]} <path_to_treetime_executable>")


  def normpath(path: Path) -> str:
    return str(path.resolve())


  THIS_DIR = normpath(Path(__file__).parent)
  PROJECT_ROOT = normpath(Path(THIS_DIR) / '..')


  def relpath(path: Path) -> str:
    return os.path.relpath(normpath(path), PROJECT_ROOT)


  TREETIME_BIN = normpath(Path(sys.argv[1]))
  DATA_DIR = relpath(Path(PROJECT_ROOT) / 'data')
  RESULTS_DIR = relpath(Path(PROJECT_ROOT) / 'tmp/smoke-tests')
  RESULTS_DIR_ADDITIONAL = Path(RESULTS_DIR) / 'additional'

  num_cores = cpu_count()

  batches = [
    (run_clock, CLOCK_BATCH_RUNS),
    (run_ancestral, [("parsimony", None, *args) for args in ANCESTRAL_BATCH_RUNS]),
    (run_ancestral, [("marginal", "sparse", *args) for args in ANCESTRAL_BATCH_RUNS]),
    (run_ancestral, [("marginal", "dense", *args) for args in ANCESTRAL_BATCH_RUNS]),
    (run_additional_cmd, make_additional_commands(TREETIME_BIN, DATA_DIR, RESULTS_DIR_ADDITIONAL))
  ]

  with Pool(processes=num_cores, initializer=init_worker) as pool:
    try:
      results = [pool.starmap_async(func, args) for func, args in batches]
      results = [code for result in results for code in result.get()]
      print_summary(results)
    except KeyboardInterrupt:
      pool.terminate()
      pool.close()
    finally:
      pool.close()
      pool.join()
